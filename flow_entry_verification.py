from ryu.base import app_manager
from ryu.controller import ofp_event
from ryu.controller.handler import *
from ryu.ofproto import ofproto_v1_3
from ryu.lib.mac import haddr_to_bin 
from ryu.lib.packet import *
import json



class flow_entry_verification(app_manager.RyuApp):
    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]
    def __init__(self, *args, **kwargs):
        super(flow_entry_verification, self).__init__(*args, **kwargs)
        self.SWITCH_NUM = 5
        self.switch_counter = 0
        self.cookie_counter = 1  #for flow entry
        self.switch_info = {}
        self.graph = {}
        
        for i in xrange(1,self.SWITCH_NUM+1):
            self.graph[i] = set()
    
    def add_flow(self, datapath, match, out_port, buffer_id=None):   #only action with output
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        actions = [parser.OFPActionOutput(out_port)]  #port for destination switch
        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,actions)]
        mod = parser.OFPFlowMod(datapath=datapath, cookie=self.cookie_counter, priority=0, match=match, instructions=inst)    #Modify flow table
        self.cookie_counter += 1
        datapath.send_msg(mod)

    def send_packet_out(self, datapath, buffer_id, in_port, actions, data=None):    #craft a packet and send with packet_out
        ofp = datapath.ofproto
        parser = datapath.ofproto_parser
        if data:
            req = ofp_parser.OFPPacketOut(datapath, buffer_id, in_port, actions, data)
        else:
            req = ofp_parser.OFPPacketOut(datapath, buffer_id, in_port, actions)
        self.logger.info('Sending packet_out:')
        self.logger.info('%s',json.dumps(msg.to_jsondict(), ensure_ascii=True, indent=3, sort_keys=True))
        datapath.send_msg(req)

    def read_flow_entry(self):  #read from a file generated by topology.py
        with open('topology/proactive_flow_entry.txt') as f: 
            for line in f:
                switch, match_field, match_value, out_port = line.rstrip().split(',')
                switch,out_port = int(switch), int(out_port)
                print switch, match_field, match_value, out_port
                exec_str = 'match = self.switch_info[switch].ofproto_parser.OFPMatch('   #string to be executed
                if match_field[:4] == 'ipv4': 
                    exec_str += 'eth_type=0x0800, %s=\'%s\')' % (match_field, match_value)
                elif match_field[:4] == 'ipv6':
                    exec_str += 'eth_type=0x86DD, %s=\'%s\')' % (match_field, match_value)
                elif match_field[:3] == 'tcp':
                    exec_str += 'eth_type=0x0800, ip_proto=0x6, %s=%s)' % (match_field, match_value)
                elif match_field[:3] == 'udp':
                    exec_str += 'eth_type=0x0800, ip_proto=0x11, %s=%s)' % (match_field, match_value)
                elif match_field[:6] == 'icmpv4':
                    exec_str += 'eth_type=0x0800, ip_proto=0x1, %s=%s)' % (match_field, match_value)
                elif match_field[:6] == 'icmpv6':
                    exec_str += 'eth_type=0x86DD, ip_proto=0x3a, %s=%s)' % (match_field, match_value)
                elif match_field[:3] == 'eth':
                    exec_str += '%s=\'%s\')' % (match_field, match_value)
                else:
                    exec_str += '%s=%s)' % (match_field, match_value)
                exec(exec_str)
                self.add_flow(self.switch_info[switch], match, out_port)    #install new flow entry
                self.graph[switch].add((switch,match_field,match_value,out_port))

    def get_dst_count(self):
        ret = {}
        for i in xrange(1,self.SWITCH_NUM+1):
            ret[i] = 0
        for switch in self.graph:
            for entry in switch:
                switch,match_field,value,out_port = entry
                ret[entry]

    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)
    def switch_features_handler(self, ev):
        datapath = ev.msg.datapath

        msg = ev.msg
        parser = datapath.ofproto_parser
        
        self.switch_info[datapath.id] = datapath #get info of every switch when switch feature
        self.switch_counter += 1

        if self.switch_counter == self.SWITCH_NUM:    #all switch ready
            self.read_flow_entry()
            print self.graph
        
        #if datapath.id == SWITCH_NUM:
            #[3,2,4,2,1]
            #self.add_flow(switch_id, match, out_port)

            #self.read_flow_entry()  #generate proactive flow entries if all switch is loaded
    
        #actions = [parser.OFPActionOutput(ofproto.OFPP_TABLE)]  #packet out to first table
        #send_packet_out(datapath, msg.buffer_id, msg.in_port, actions)
        #send packet out to out_port
'''
show detail info in json
#self.logger.info('%s',json.dumps(msg.to_jsondict(), ensure_ascii=True, indent=3, sort_keys=True))

Packet_Out reference
#OFPP_TABLE -> send to first flow table.
#OFPP_ALL Forwarded to all physical ports except receiving ports
#OFPP_CONTROLLER -> send to controller

packet generating reference:
 def _handle_icmp(self, datapath, port, pkt_ethernet, pkt_ipv4, pkt_icmp):
        if pkt_icmp.type != icmp.ICMP_ECHO_REQUEST:
            return
        pkt = packet.Packet()
        pkt.add_protocol(ethernet.ethernet(ethertype=pkt_ethernet.ethertype,
                                           dst=pkt_ethernet.src,
                                           src=self.hw_addr))
        pkt.add_protocol(ipv4.ipv4(dst=pkt_ipv4.src,
                                   src=self.ip_addr,
                                   proto=pkt_ipv4.proto))
        pkt.add_protocol(icmp.icmp(type_=icmp.ICMP_ECHO_REPLY,
                                   code=icmp.ICMP_ECHO_REPLY_CODE,
                                   csum=0,
                                   data=pkt_icmp.data))
        self._send_packet(datapath, port, pkt)

    def _send_packet(self, datapath, port, pkt):
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        pkt.serialize()
        self.logger.info("packet-out %s" % (pkt,))
        data = pkt.data
        actions = [parser.OFPActionOutput(port=port)]
        out = parser.OFPPacketOut(datapath=datapath,
                                  buffer_id=ofproto.OFP_NO_BUFFER,
                                  in_port=ofproto.OFPP_CONTROLLER,
                                  actions=actions,
                                  data=data)
        datapath.send_msg(out)


###trigger 
@set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
def packet_in_handler(self, ev):
    msg = ev.msg
    dp = msg.datapath
    ofp = dp.ofproto

    if msg.reason == ofp.OFPR_NO_MATCH:
        reason = 'NO MATCH'
    elif msg.reason == ofp.OFPR_ACTION:
        reason = 'ACTION'
    elif msg.reason == ofp.OFPR_INVALID_TTL:
        reason = 'INVALID TTL'
    else:
        reason = 'unknown'

    self.logger.debug('OFPPacketIn received: '
                      'buffer_id=%x total_len=%d reason=%s '
                      'table_id=%d cookie=%d match=%s data=%s',
                      msg.buffer_id, msg.total_len, reason,
                      msg.table_id, msg.cookie, msg.match,
                      utils.hex_array(msg.data))

#####install flow entry sample
    match = parser.OFPMatch(eth_type = 0x0800, ipv4_src='140.123.103.188')  #ip
    match = parser.OFPMatch(eth_type = 0x0800, ip_proto=0x6, tcp_src=1234)    #tcp
    match = parser.OFPMatch(eth_type = 0x0800, ip_proto=0x11, udp_src=1234) #udp
    match = parser.OFPMatch(eth_type = 0x86DD, ip_proto=0x6, ipv6_src="2607:f0d0:1002:0051:0000:0000:0000:0004", tcp_src=1234)    #ip_v6 with tcp
    match = parser.OFPMatch(eth_type = 0x86DD, ip_proto=0x6, ipv6_src="2607:f0d0:1002:0051:0000:0000:0000:0004", tcp_src=1234, eth_src='0a:00:27:00:00:00')   #eth_src dst can fit in all
    match = parser.OFPMatch(eth_type = 0x0800, ip_proto=0x11, udp_src=1234, vlan_vid=0x1fff)    # vlan, max value here
    match = parser.OFPMatch(eth_type = 0x0800, ip_proto=0x1, icmpv4_type=10,icmpv4_code=1)
    match = parser.OFPMatch(eth_type = 0x0800, ip_proto=0x3a, icmpv6_code=1)
    icmp type, code => 8bits


'''