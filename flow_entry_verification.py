from ryu.base import app_manager
from ryu.controller import ofp_event
from ryu.controller.handler import *
from ryu.ofproto import ofproto_v1_3
from ryu.lib.mac import haddr_to_bin 
from ryu.lib.packet import *

import sys
import ryu
import json
import topo_gen
import array
import time
import binascii
import inspect
import pprint

f = open('config/'+topo_gen.config_file,'r')
content = f.read().split(',')
f.close()
SWITCH_NUM, TOTAL_ENTRY = int(content[0]), int(content[2])
TOTAL_LINK = 0
packet_in_counter = 0

class flow_entry_verification(app_manager.RyuApp):
    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]
    def __init__(self, *args, **kwargs):
        super(flow_entry_verification, self).__init__(*args, **kwargs)
        global SWITCH_NUM
        self.switch_counter = 0
        self.expected_packetin = 0
        self.unvisited_entry_in_switch = {}
        for i in xrange(1,SWITCH_NUM+1):
            self.unvisited_entry_in_switch[i] = 0
        self.entry_counter = 0
        self.additional_entry = 0
        self.pkt = {}
        self.switch_info = {}   #switch_info[datapath_id] = datapath object
        self.graph = {} #format: graph[switch] = [ (entry1 => match_field, value, destination_switch) (entry2) (entry3) ... ]
        self.group_counter = 0
        self.group_info = [] #keep the path info of each group, group_info[switch] = [list of switch it connect to]      
        self.dst_switch_to_port = {} #the port dst switch is at, ex: dst_switch_to_port[on_switch][dst_switch]
        for i in xrange(1,SWITCH_NUM+1):
            self.dst_switch_to_port[i] = {}
        
    def add_flow(self, datapath, match, out_port, cookie_counter=0, buffer_id=None, priority=3, hard_timeout=0, table_id=0):   #only action with output
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        actions = [parser.OFPActionOutput(i) for i in out_port]
        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,actions)]
        mod = parser.OFPFlowMod(datapath=datapath, cookie=cookie_counter, priority=priority, match=match, instructions=inst, hard_timeout=hard_timeout, table_id=table_id)    #Modify flow table
        datapath.send_msg(mod)

    def send_packet_out(self, datapath, in_port, data):    #forge a packet and send packet_out
        ofp = datapath.ofproto
        parser = datapath.ofproto_parser
        actions = [datapath.ofproto_parser.OFPActionOutput(ofp.OFPP_TABLE)]
        req = parser.OFPPacketOut(datapath=datapath, buffer_id=ofp.OFP_NO_BUFFER, in_port=datapath.ofproto.OFPP_CONTROLLER, actions=actions, data=data)
        #datapath.send_msg(req)

    def read_flow_entry(self):  #read from a file generated by topology.py
        global SWITCH_NUM
        f = open('config/'+topo_gen.config_file+'.port_to_switch','r')
        dst_switch = eval(f.read())
        f.close()
        cookie_counter = 1
        global TOTAL_LINK

        for i in xrange(1,SWITCH_NUM+1):
            self.graph[i] = set()
            TOTAL_LINK += len(dst_switch[i])
        with open('config/'+topo_gen.config_file+'.entry','r') as f:
            for line in f:
                switch, match_field, match_value, out_port, priority = line.rstrip().split(',')
                switch, out_port, priority = int(switch), int(out_port), int(priority)
                exec_str = 'match = self.switch_info[switch].ofproto_parser.OFPMatch('   #string to be executed
                if match_field[:4] == 'ipv4': 
                    exec_str += 'eth_type=0x800, %s=\'%s\')' % (match_field, match_value)
                elif match_field[:4] == 'ipv6':
                    exec_str += 'eth_type=0x86DD, %s=\'%s\')' % (match_field, match_value)
                elif match_field[:3] == 'tcp':
                    exec_str += 'eth_type=0x800, ip_proto=0x6, %s=%s)' % (match_field, match_value)
                elif match_field[:3] == 'udp':
                    exec_str += 'eth_type=0x800, ip_proto=0x11, %s=%s)' % (match_field, match_value)
                elif match_field[:6] == 'icmpv4':
                    exec_str += 'eth_type=0x800, ip_proto=0x1, %s=%s)' % (match_field, match_value)
                elif match_field[:6] == 'icmpv6':
                    exec_str += 'eth_type=0x86DD, ip_proto=0x3a, %s=%s)' % (match_field, match_value)
                elif match_field[:3] == 'eth':
                    exec_str += '%s=\'%s\')' % (match_field, match_value)
                else:
                    exec_str += '%s=%s)' % (match_field, match_value)
                exec(exec_str)
                self.add_flow(self.switch_info[switch], match, [out_port], cookie_counter=cookie_counter, priority=priority)    
                if dst_switch[switch][out_port][0] == 'h': #port direct to a host
                    self.graph[switch].add((match_field,match_value,-int(dst_switch[switch][out_port][1:]),cookie_counter,priority))
                else:
                    self.dst_switch_to_port[switch][int(dst_switch[switch][out_port][1:])] = out_port
                    self.graph[switch].add((match_field,match_value,int(dst_switch[switch][out_port][1:]),cookie_counter,priority))
                field_value_set = (match_field,match_value)
                cookie_counter += 1
                self.unvisited_entry_in_switch[switch] += 1
        #pprint.pprint(self.graph)

    def find_aggregate_groups(self):
        global SWITCH_NUM
        time.sleep(2)
        start_time = time.time()
        visited_entry = set()   #cookie of visited entries
        switches = range(1,SWITCH_NUM+1)
        while switches:
            starting_switch = min(switches)
            visited_switch = set()
            self.group_info.append(dict())
            self.group_info[self.group_counter]['start'] = starting_switch
            self.group_info[self.group_counter]['end'] = []
            self.pkt['group_id'] = self.group_counter
            self.find_one_group(starting_switch,visited_switch,visited_entry)
            real_packet = self.assemble_packet(self.pkt)
            real_packet.serialize()
            #self.get_end_switches(self.group_info[self.group_counter]['start'])    #it'll add temp entry at split point
            self.send_packet_out(self.switch_info[starting_switch],self.switch_info[1].ofproto.OFPP_CONTROLLER,real_packet.data)
            for i in self.group_info[self.group_counter]:
                if i!='start' and i!='end' and self.unvisited_entry_in_switch[i] == 0 and i in switches:
                    switches.remove(i)
            self.group_counter += 1
            del self.pkt
            del visited_switch
            self.pkt = {}

        print 'topology type:%s\n---------------' % topo_gen.config_file
        print 'switch num:%d\nlink num:%d\ntotal entry: %d\ntotal group: %d\nadditional entry: %d' % (SWITCH_NUM, TOTAL_LINK, TOTAL_ENTRY, self.group_counter, self.additional_entry)
        print 'Average link:%f Effective aggregation rate: %f' % (float(TOTAL_LINK)/float(SWITCH_NUM),float(TOTAL_ENTRY)/float(self.group_counter))
        end_time = time.time()
        print 'Execution time: %f\nAdd entry wait time: %f' % (end_time - start_time, self.additional_entry*0.01) 
        ele_count = {}

        for i in xrange(0,self.group_counter):
            len_of_group = 0
            for j in self.group_info[i]:
                if j != 'start' and j!='end':
                    if len(self.group_info[i][j]) == 0:
                        len_of_group += 1
                    else:
                        len_of_group += len(self.group_info[i][j])

            if len_of_group not in ele_count:
                ele_count[len_of_group] = 1
            else:
                ele_count[len_of_group] += 1
        in_group_entry = 0 
        print '\n'
        for i in ele_count:
            in_group_entry += ele_count[i] * i
        print 'Average entry in group: %f' % (float(in_group_entry) / float(self.group_counter))
        sys.exit()

    def find_one_group(self, switch, visited_switch, visited_entry):    #find flow entry that fit in the group recursively
        if switch in visited_switch:    #XXXXX
            return
        most_prior_entry, highest_priority = None, -1
        self.group_info[self.group_counter][switch] = []
        visited_switch.add(switch)
        for entry in self.graph[switch]:
            field, value, dst_switch, cookie, priority = entry
            if field in self.pkt and self.pkt[field] == value and priority > highest_priority:
                highest_priority, most_prior_entry = priority, entry

        if highest_priority != -1:  #find a same field,value
            field, value, dst_switch, cookie, priority = most_prior_entry
            if cookie not in visited_entry:
                self.entry_counter += 1
                visited_entry.add(cookie)
                self.unvisited_entry_in_switch[switch] -= 1
            if dst_switch < 0:    #next hop is a host, installed a entry to send back to controller
                match = self.switch_info[1].ofproto_parser.OFPMatch(vlan_vid=0x1000+self.pkt['group_id'])
                self.add_flow(self.switch_info[switch], match, [self.switch_info[switch].ofproto.OFPP_CONTROLLER], priority=12345)
                time.sleep(0.01)
                return
            else:
                self.group_info[self.group_counter][switch].append(most_prior_entry)
                self.find_one_group(dst_switch, visited_switch, visited_entry) 

        highest_heu = -1
        for entry in self.graph[switch]:
            match_field, value, dst_switch, cookie, priority = entry
            if cookie not in visited_entry and dst_switch not in visited_switch and self.if_fit_group(entry,self.pkt) and not self.in_previous_switch((match_field,value),switch): #this entry fit in the group!
                #the entry can fit in the current group!
                self.entry_counter += 1
                visited_entry.add(cookie)
                self.pkt[match_field] = value
                self.unvisited_entry_in_switch[switch] -= 1
                if dst_switch < 0 :    #next hop is a host, installed a entry to send back to controller
                    match = self.switch_info[1].ofproto_parser.OFPMatch(vlan_vid=0x1000+self.pkt['group_id'],)
                    self.add_flow(self.switch_info[switch], match, [self.switch_info[switch].ofproto.OFPP_CONTROLLER], priority=12345)
                    self.expected_packetin += 1
                    self.additional_entry += 1
                    time.sleep(0.01)
                    return 
                self.group_info[self.group_counter][switch].append(entry)   #Only 'switch' is added to group info
                self.find_one_group(dst_switch,visited_switch,visited_entry)
        return

    def in_previous_switch(self,fv_set,cur): #same field+value in other group..might match and mis-forward
        for switch_index in self.group_info[self.group_counter]:
            if switch_index != 'start' and switch_index !='end' and switch_index != cur:
                for entry in self.graph[switch_index]:
                    field, value, dst_switch, cookie, priority = entry
                    if (field,value) == fv_set:
                        return True
        return False

    def if_fit_group(self,entry,pkt): #see if the entry fit in the group
        match_field, value, dst_switch, cookie, priority = entry
        if match_field in pkt and pkt[match_field] != value:
                return False
        if match_field[:3] == 'tcp':
            if 'udp_src' in pkt or 'udp_dst' in pkt or 'icmpv4_type' in pkt or 'icmpv4_code' in pkt or 'icmpv6_type' in pkt or 'icmpv6_code' in pkt:
                return False
        elif match_field[:3] == 'udp':
            if 'tcp_src' in pkt or 'tcp_dst' in pkt or 'icmpv4_type' in pkt or 'icmpv4_code' in pkt or 'icmpv6_type' in pkt or 'icmpv6_code' in pkt:
                return False
        elif match_field[:6] == 'icmpv4':
            if 'udp_src' in pkt or 'udp_dst' in pkt or 'tcp_src' in pkt or 'tcp_dst' in pkt or 'icmpv6_type' in pkt or 'icmpv6_code' in pkt: 
                return False
        elif match_field[:6] == 'icmpv6':
            if 'udp_src' in pkt or 'udp_dst' in pkt or 'tcp_src' in pkt or 'tcp_dst' in pkt or 'icmpv4_type' in pkt or 'icmpv4_code' in pkt:
                return False
        elif match_field[:4] == 'ipv4': 
            if 'ipv6_src' in pkt or 'ipv6_dst' in pkt or 'icmpv6_type' in pkt or 'icmpv6_code' in pkt:
                return False
        elif match_field[:4] == 'ipv6':
            if 'ipv4_src' in pkt or 'ipv4_dst' in pkt or 'icmpv4_type' in pkt or 'icmpv4_code' in pkt:
                return False
        return True

    def assemble_packet(self,pkt):  #turn packet into packet API format
        #default value
        eth_dst, eth_src = 0,0
        ipv4_src, ipv4_dst = 0,0
        ipv6_src, ipv6_dst = '0:0:0:0:0:0:0:0','0:0:0:0:0:0:0:0'
        tcp_src, tcp_dst = 0,0
        udp_src, udp_dst = 0,0
        icmpv4_code, icmpv4_type = 0,0
        icmpv6_code, icmpv6_type = 0,0
        ethertype, proto = 0x800,0

        real_packet = packet.Packet()
        for field in pkt:
            exec(field+'=pkt[\''+field+'\']')

        #ether type default for ipv4
        if 'ipv6_src' in pkt or 'ipv6_dst' in pkt or 'icmpv6_type' in pkt or 'icmpv6_code' in pkt:
            ethertype = 0x86DD

        e = ethernet.ethernet(src=eth_src,dst=eth_dst,ethertype=0x8100)
        real_packet.add_protocol(e)

        v = vlan.vlan(vid=pkt['group_id'],ethertype=ethertype)
        real_packet.add_protocol(v)

        if 'tcp_src' in pkt or 'tcp_dst' in pkt:
            proto = 0x6
        elif 'udp_src' in pkt or 'udp_dst' in pkt:
            proto = 0x11
        elif 'icmpv4_type' in pkt or 'icmpv4_code' in pkt:
            proto = 0x1
        elif 'icmpv6_type' in pkt or 'icmpv6_code' in pkt:
            proto = 0x3a

        if 'ipv6_src' in pkt or 'ipv6_dst' in pkt or 'icmpv6_code' in pkt or 'icmpv6_type' in pkt:
            v.ethertype=0x86DD
            ip = ipv6.ipv6(src=ipv6_src,dst=ipv6_dst,nxt=proto)
        else:
            ip = ipv4.ipv4(src=ipv4_src,dst=ipv4_dst,proto=proto)
        real_packet.add_protocol(ip)

        if 'tcp_src' in pkt or 'tcp_dst' in pkt:
            tui = tcp.tcp(src_port=int(tcp_src), dst_port=int(tcp_dst))    
            real_packet.add_protocol(tui)
        elif 'udp_src' in pkt or 'udp_dst' in pkt:
            tui = udp.udp(src_port=int(udp_src), dst_port=int(udp_dst))
            real_packet.add_protocol(tui)
        elif 'icmpv4_type' in pkt or 'icmpv4_code' in pkt:
            tui = icmp.icmp(type_=int(icmpv4_type),code=int(icmpv4_code))
            real_packet.add_protocol(tui)
        elif 'icmpv6_type' in pkt or 'icmpv6_code' in pkt:
            tui = icmpv6.icmpv6(type_=int(icmpv6_type),code=int(icmpv6_code))
            real_packet.add_protocol(tui)
        return real_packet

    def heuristic(self,entry):
        match_field, value, dst_switch, cookie, priority = entry
        if dst_switch > 0:
            #return len(self.graph[dst_switch])
            return dst_switch
            return -dst_switch+100

    def get_end_switches(self,cur):
        parser = self.switch_info[1].ofproto_parser
        if len(self.group_info[self.group_counter][cur]) == 0:   # leaf 
            self.group_info[self.group_counter]['end'].append(cur)
            return

        elif len(self.group_info[self.group_counter][cur]) > 1:
            out_port = []
            for i in self.group_info[self.group_counter][cur]:
                field, value, dst_switch, cookie, priority = i
                out_port.append(self.dst_switch_to_port[cur][dst_switch])
            self.expected_packetin += len(out_port)
            match = parser.OFPMatch(vlan_vid=0x1000 + self.group_counter)
            self.add_flow(self.switch_info[cur], match, out_port, priority=22222,hard_timeout=700)
            time.sleep(0.01)
            
        for i in self.group_info[self.group_counter][cur]:
            match_field, value, dst_switch, cookie, priority = i
            if dst_switch > 0:
                self.get_end_switches(dst_switch)

    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)
    def switch_features_handler(self, ev):
        datapath = ev.msg.datapath
        msg = ev.msg
        parser = datapath.ofproto_parser
        #table-miss
        match=parser.OFPMatch()
        self.add_flow(datapath,match,[datapath.ofproto.OFPP_CONTROLLER],priority=0)   
        self.switch_info[datapath.id] = datapath #save datapath object of every switch
        self.switch_counter += 1
        global SWITCH_NUM
        if self.switch_counter == SWITCH_NUM:    #all switch ready   
            self.read_flow_entry()  #read proactive installed entries
            self.find_aggregate_groups()
            
    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
    def check_packet_back(self, ev):    #check if packets come back as expected
        global packet_in_counter 
        packet_in_counter += 1
        msg = ev.msg
        dp = msg.datapath
        ofp = dp.ofproto
        pkt = packet.Packet(array.array('B', ev.msg.data))
        if msg.reason == ofp.OFPR_NO_MATCH:
            reason = 'NO MATCH'
        elif msg.reason == ofp.OFPR_ACTION:
            reason = 'ACTION'
        elif msg.reason == ofp.OFPR_INVALID_TTL:
            reason = 'INVALID TTL'
        else:
            reason = 'unknown'
        for p in pkt.protocols: #print receiving packet
            if p.protocol_name == 'vlan':
                group_id = p.vid
                break

        if dp.id not in self.group_info[group_id]['end']:
            print 'should be in '
            print self.group_info[group_id]['end']
        else:
            self.group_info[group_id]['end'].remove(dp.id)

        if packet_in_counter == self.expected_packetin:  #the last group
            time.sleep(1)
            for i in xrange(len(self.group_info)):
                if len(self.group_info[i]['end']) > 0:
                    for j in self.group_info[i]['end']:
                        print 'In vid=%d the %d end didnt arrive' % (i,j)
            pass 
            