from ryu.base import app_manager
from ryu.controller import ofp_event
from ryu.controller.handler import *
from ryu.ofproto import ofproto_v1_3
from ryu.lib.mac import haddr_to_bin 
from ryu.lib.packet import *
import json

SWITCH_NUM = 5
cookie_counter = 1

class flow_entry_verification(app_manager.RyuApp):
    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]
    def __init__(self, *args, **kwargs):
        super(flow_entry_verification, self).__init__(*args, **kwargs)
        self.mac_to_port = {}
    
    def add_flow(self, datapath, match, out_port, buffer_id=None):   #only action with output
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser   
        global cookie_counter
        actions = [parser.OFPActionOutput(out_port)]  #port for destination switch
        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,actions)]
        mod = parser.OFPFlowMod(datapath=datapath, cookie=cookie_counter, priority=0, match=match, instructions=inst)    #Modify flow table
        cookie_counter += 1
        datapath.send_msg(mod)

    def send_packet_out(self, datapath, buffer_id, in_port, actions, data=None):    #craft a packet and send with packet_out
        ofp = datapath.ofproto
        ofp_parser = datapath.ofproto_parser
        if data:
            req = ofp_parser.OFPPacketOut(datapath, buffer_id, in_port, actions, data)
        else:
            req = ofp_parser.OFPPacketOut(datapath, buffer_id, in_port, actions)
        self.logger.info('Sending packet_out:')
        self.logger.info('%s',json.dumps(msg.to_jsondict(), ensure_ascii=True, indent=3, sort_keys=True))
        datapath.send_msg(req)

    def read_flow_entry():  #read from a file generated by topology.py

        with open('proactive_flow_entry.txt') as f: 
            for line in f:
                print line.split(',')
                #match = parser.OFPMatch(eth_type = 0x806)  #match field and value
                #self.add_flow(datapath, match, actions, inst)    #install new flow entry

    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)
    def switch_features_handler(self, ev):
        datapath = ev.msg.datapath
        msg = ev.msg
 
        self.logger.info('switch %d on!!' % datapath.id)

        if datapath.id == 1:
            match = datapath.ofproto_parser.OFPMatch(eth_type = 0x0800, ipv4_src='140.123.103.188', eth_src='0a:00:27:00:00:00')
            out_port = 1
            self.add_flow(datapath, match, out_port)

        '''elif datapath.id == 2:
        elif datapath.id == 3:
        elif datapath.id == 4:
        elif datapath.id == 5:'''
        #if datapath.id == SWITCH_NUM:
            #[3,2,4,2,1]
            #self.add_flow(switch_id, match, out_port)



            #self.read_flow_entry()  #generate proactive flow entries if all switch is loaded
    
        #actions = [parser.OFPActionOutput(ofproto.OFPP_TABLE)]  #packet out to first table
        #send_packet_out(datapath, msg.buffer_id, msg.in_port, actions)
        #send packet out to out_port
        '''
        if datapath.id == 1:        ## SWITCH 1
            match = parser.OFPMatch(eth_type = 0x0800, ipv4_src = "10.0.0.1", ipv4_dst = "10.0.0.5")#h1 to h5
            actions = [parser.OFPActionOutput(3)]
            inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,actions)]
            self.add_flow(datapath, 0, match, actions, inst)
        '''
    
    
'''
show detail info in json
#self.logger.info('%s',json.dumps(msg.to_jsondict(), ensure_ascii=True, indent=3, sort_keys=True))

Packet_Out reference
#OFPP_TABLE -> send to first flow table.
#OFPP_ALL Forwarded to all physical ports except receiving ports
#OFPP_CONTROLLER -> send to controller

packet generating reference:
 def _handle_icmp(self, datapath, port, pkt_ethernet, pkt_ipv4, pkt_icmp):
        if pkt_icmp.type != icmp.ICMP_ECHO_REQUEST:
            return
        pkt = packet.Packet()
        pkt.add_protocol(ethernet.ethernet(ethertype=pkt_ethernet.ethertype,
                                           dst=pkt_ethernet.src,
                                           src=self.hw_addr))
        pkt.add_protocol(ipv4.ipv4(dst=pkt_ipv4.src,
                                   src=self.ip_addr,
                                   proto=pkt_ipv4.proto))
        pkt.add_protocol(icmp.icmp(type_=icmp.ICMP_ECHO_REPLY,
                                   code=icmp.ICMP_ECHO_REPLY_CODE,
                                   csum=0,
                                   data=pkt_icmp.data))
        self._send_packet(datapath, port, pkt)

    def _send_packet(self, datapath, port, pkt):
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        pkt.serialize()
        self.logger.info("packet-out %s" % (pkt,))
        data = pkt.data
        actions = [parser.OFPActionOutput(port=port)]
        out = parser.OFPPacketOut(datapath=datapath,
                                  buffer_id=ofproto.OFP_NO_BUFFER,
                                  in_port=ofproto.OFPP_CONTROLLER,
                                  actions=actions,
                                  data=data)
        datapath.send_msg(out)


###trigger 
@set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
def packet_in_handler(self, ev):
    msg = ev.msg
    dp = msg.datapath
    ofp = dp.ofproto

    if msg.reason == ofp.OFPR_NO_MATCH:
        reason = 'NO MATCH'
    elif msg.reason == ofp.OFPR_ACTION:
        reason = 'ACTION'
    elif msg.reason == ofp.OFPR_INVALID_TTL:
        reason = 'INVALID TTL'
    else:
        reason = 'unknown'

    self.logger.debug('OFPPacketIn received: '
                      'buffer_id=%x total_len=%d reason=%s '
                      'table_id=%d cookie=%d match=%s data=%s',
                      msg.buffer_id, msg.total_len, reason,
                      msg.table_id, msg.cookie, msg.match,
                      utils.hex_array(msg.data))


@set_ev_cls(ofp_event.EventOFPPortStatus, MAIN_DISPATCHER)
    def _port_status_handler(self, ev):
        msg = ev.msg
        reason = msg.reason 
        port_no = msg.desc.port_no
        ofproto = msg.datapath.ofproto
        if reason == ofproto.OFPPR_ADD:
            self.logger.info("port added %s", port_no)
        elif reason == ofproto.OFPPR_DELETE:
            self.logger.info("port deleted %s", port_no)
        elif reason == ofproto.OFPPR_MODIFY:
            self.logger.info("port modified %s", port_no)
        else:
            self.logger.info("Illegal port state %s %s", port_no, reason)


#####install flow entry sample
    match = parser.OFPMatch(eth_type = 0x0800, ipv4_src='140.123.103.188')  #ip
    match = parser.OFPMatch(eth_type = 0x0800, ip_proto=0x6, tcp_src=1234)    #tcp
    match = parser.OFPMatch(eth_type = 0x0800, ip_proto=0x11, udp_src=1234) #udp
    match = parser.OFPMatch(eth_type = 0x86DD, ip_proto=0x6, ipv6_src="2607:f0d0:1002:0051:0000:0000:0000:0004", tcp_src=1234)    #ip_v6 with tcp
    match = parser.OFPMatch(eth_type = 0x86DD, ip_proto=0x6, ipv6_src="2607:f0d0:1002:0051:0000:0000:0000:0004", tcp_src=1234, eth_src='0a:00:27:00:00:00')   #eth_src dst can fit in all
    match = parser.OFPMatch(eth_type = 0x0800, ip_proto=0x11, udp_src=1234, vlan_vid=0x1fff)    # vlan, max value here
    match = parser.OFPMatch(eth_type = 0x0800, ip_proto=0x1, icmpv4_type=10,icmpv4_code=1)
    match = parser.OFPMatch(eth_type = 0x0800, ip_proto=0x3a, icmpv6_code=1)
    icmp type, code => 8bits


'''